% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inferCSN.R, R/inferCSN-methods.R
\docType{methods}
\name{inferCSN}
\alias{inferCSN}
\alias{inferCSN,matrix-method}
\alias{inferCSN,sparseMatrix-method}
\alias{inferCSN,data.frame-method}
\alias{inferCSN,Network-method}
\alias{inferCSN,CSNObject-method}
\alias{inferCSN,Seurat-method}
\title{\strong{infer}ring \strong{C}ell-\strong{S}pecific gene regulatory \strong{N}etwork}
\usage{
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

\S4method{inferCSN}{matrix}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

\S4method{inferCSN}{sparseMatrix}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

\S4method{inferCSN}{data.frame}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

\S4method{inferCSN}{Network}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  method = "srm",
  gene_cor_threshold = 0,
  ...
)

\S4method{inferCSN}{CSNObject}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  celltypes = NULL,
  network_name = paste0(method, "_network"),
  peak_to_gene_method = c("Signac", "GREAT"),
  upstream = 1e+05,
  downstream = 0,
  extend = 1e+06,
  only_tss = FALSE,
  peak_to_gene_domains = NULL,
  gene_cor_threshold = 0.1,
  peak_cor_threshold = 0,
  aggregate_rna_col = NULL,
  aggregate_peaks_col = NULL,
  method = c("srm", "glm", "glmnet", "cv.glmnet", "brms", "xgb"),
  alpha = 0.5,
  family = "gaussian",
  interaction_term = ":",
  adjust_method = "fdr",
  scale = FALSE,
  ...
)

\S4method{inferCSN}{Seurat}(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  subsampling_method = "sample",
  subsampling_ratio = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{object}{The input data for \emph{\code{inferCSN}}.}

\item{penalty}{The type of regularization, default is \emph{\code{L0}}.
This can take either one of the following choices: \emph{\code{L0}}, \emph{\code{L0L1}}, and \emph{\code{L0L2}}.
For high-dimensional and sparse data, \emph{\code{L0L2}} is more effective.}

\item{algorithm}{The type of algorithm used to minimize the objective function, default is \emph{\code{CD}}.
Currently \emph{\code{CD}} and \emph{\code{CDPSI}} are supported.
The \emph{\code{CDPSI}} algorithm may yield better results, but it also increases running time.}

\item{cross_validation}{Logical value, default is \emph{\code{FALSE}}, whether to use cross-validation.}

\item{seed}{The random seed for cross-validation, default is \emph{\code{1}}.}

\item{n_folds}{The number of folds for cross-validation, default is \emph{\code{10}}.}

\item{subsampling_method}{The method to use for subsampling. Options are "sample" or "meta_cells".}

\item{subsampling_ratio}{The percent of all samples used for \code{\link{sparse_regression}}, default is \emph{\code{1}}.}

\item{r_threshold}{Threshold of \eqn{R^2} or correlation coefficient, default is \emph{\code{0}}.}

\item{regulators}{The regulator genes for which to infer the regulatory network.}

\item{targets}{The target genes for which to infer the regulatory network.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.}

\item{cores}{The number of cores to use for parallelization with \code{\link[foreach]{foreach}}, default is \emph{\code{1}}.}

\item{verbose}{Logical value, default is \emph{\code{TRUE}}, whether to print progress messages.}

\item{...}{Parameters for other methods.}

\item{method}{A character string indicating the method to fit the model.
* \code{'srm'} - Sparse Regression Model.
* \code{'glm'} - Generalized Liner Model with \code{\link[stats]{glm}}.
* \code{'glmnet'}, \code{'cv.glmnet'} - Regularized Generalized Liner Model with \code{\link[glmnet]{glmnet}}.
* \code{'brms'} - Bayesian Regression Models using \code{\link[brms]{brms-package}}.
* \code{'xgb'} - Gradient Boosting Regression using \code{\link[xgboost]{xgboost}}.}

\item{gene_cor_threshold}{Threshold for TF - target gene correlation.}

\item{celltypes}{Character vector of cell types to infer networks for.}

\item{network_name}{network_name.}

\item{peak_to_gene_method}{Character specifying the method to
link peak overlapping motif regions to nearby genes. One of \code{Signac} or \code{GREAT}.}

\item{upstream}{Integer defining the distance upstream of the gene to consider as potential regulatory region.}

\item{downstream}{Integer defining the distance downstream of the gene to consider as potential regulatory region.}

\item{extend}{Integer defining the distance from the upstream and downstream of the basal regulatory region.
Only used of `peak_to_gene_method = 'GREAT'`.}

\item{only_tss}{Logical. Measure distance from the TSS (\code{TRUE}) or from the entire gene body (\code{FALSE}).}

\item{peak_to_gene_domains}{\code{GenomicRanges} object with regulatory regions for each gene.}

\item{peak_cor_threshold}{Threshold for binding peak - target gene correlation.}

\item{aggregate_rna_col}{aggregate_rna_col}

\item{aggregate_peaks_col}{aggregate_peaks_col}

\item{alpha}{The elasticnet mixing parameter. See \code{\link[glmnet]{glmnet}} for details.}

\item{family}{A description of the error distribution and link function to be used in the model.
See \code{\link[stats]{family}} for mode details.}

\item{interaction_term}{The interaction variable to use in the model between TF and binding site.
* \code{'+'} for additive interaction.
* \code{':'} for 'multiplicative' interaction.
* \code{'*'} for crossing interaction, i.e. additive AND 'multiplicative'.
For more info, see \code{\link[stats]{formula}}}

\item{adjust_method}{Method for adjusting p-values.}

\item{scale}{Logical. Whether to z-transform the expression and accessibility matrices.}
}
\value{
A data table of regulator-target regulatory relationships

A CSNObject.
}
\description{
\strong{infer}ring \strong{C}ell-\strong{S}pecific gene regulatory \strong{N}etwork
}
\examples{
data("example_matrix")
data("example_ground_truth")
network_table_1 <- inferCSN(
  example_matrix
)

network_table_2 <- inferCSN(
  example_matrix,
  cores = 2
)

head(network_table_1)

identical(
  network_table_1,
  network_table_2
)

inferCSN(
  example_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
inferCSN(
  example_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g0")
)

\dontrun{
network_table_07 <- inferCSN(
  example_matrix,
  r_threshold = 0.7
)
calculate_metrics(
  network_table_1,
  example_ground_truth,
  plot = TRUE
)
calculate_metrics(
  network_table_07,
  example_ground_truth,
  plot = TRUE
)
}
\dontrun{
data("example_matrix")
network_table <- inferCSN(example_matrix)
head(network_table)

network_table_sparse_1 <- inferCSN(
  as(example_matrix, "sparseMatrix")
)
head(network_table_sparse_1)

network_table_sparse_2 <- inferCSN(
  as(example_matrix, "sparseMatrix"),
  cores = 2
)
identical(
  network_table,
  network_table_sparse_1
)

identical(
  network_table_sparse_1,
  network_table_sparse_2
)

plot_scatter(
  data.frame(
    network_table$weight,
    network_table_sparse_1$weight
  ),
  legend_position = "none"
)

plot_weight_distribution(
  network_table
) + plot_weight_distribution(
  network_table_sparse_1
)
}
}
